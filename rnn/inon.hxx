#ifndef INCLUDE_INNOVATION_NUMBER_HXX_
#define INCLUDE_INNOVATION_NUMBER_HXX_

#include <stddef.h>

#include <unordered_map>
using std::unordered_map;

#include <exception>
#include <memory>
using std::unique_ptr;

#include <functional>
using std::hash;

#include "../common/log.hxx"

template <typename T>
class inon_type {
  // To ensure that these are unique among workers (each worker gets a
  // separate mutator), each worker adds its id to the count. Next, they are
  // to be incremented by the number of total workers. This ensures unique
  // id's among workers by forcing the innovation numbers for any given worker
  // to be congruent modulo the number of workers.
  //
  // rough proof innovation numbers are unique among threads:
  // Given: worker_id w, number of workers N, and starting count s.
  // Assuming: there are workers 0 up until N - 1
  //
  //   1. the initial edge innovation count for this mutator is s + w.
  //   2. s + w === s + w (mod N)
  //   3. assume some number k innovation numbers have been generated,
  //      incrementing the count by kN
  //   4. this number is equal to s + w + kN
  //   5. s + w + kN = s + w (mod N), implying all innovation numbers
  //      generated by worker w belong to the same congruence class
  //   6. worker ids form the set of integers 0 <= x < N, which is
  //      the least residue system modulo N by definition
  //   7. considering (5) and (6) together implies all workers generate
  //      innovation numbers from different congruence classes,
  //      since each worker id represents a distinct congruence class -
  //      the starting count is irrelevent here since it is added to all
  //      of the generated innovation numbers.
  //                                                                  ┌┐
  //                                                                  └┘
  //
  //  This is the premise for this class. The MOD_CLASS is N and the
  //  innovaiton counter a starting place, which should be BASE + w
  //  for any base
  thread_local static inline size_t INNOVATION_COUNTER = 0;
  thread_local static inline size_t MOD_CLASS = 1;
  static size_t next_inon() {
    size_t x = INNOVATION_COUNTER;
    INNOVATION_COUNTER += MOD_CLASS;
    return x;
  }

 public:
  static void init(size_t counter, size_t mod_class) {
    if (mod_class < 1) {
      Log::fatal("mod_class must be greater than 0!\n");
      exit(1);
    }
    MOD_CLASS = mod_class;

    INNOVATION_COUNTER = counter;
  }

  static size_t get_count() { return INNOVATION_COUNTER; }
  size_t inon;

  // template <typename P>
  // explicit inon_type(inon_type<P> inon) : inon(inon.inon) {}
  explicit inon_type(size_t inon) : inon(inon) {}
  inon_type() : inon(next_inon()) {}
  inon_type(const inon_type &) = default;
  inon_type(inon_type &&) = default;

  template <typename P>
  inon_type<P> convert() {
    return inon_type<P>(inon);
  }

  inline bool operator==(const inon_type<T> &b) const { return inon == b.inon; }
  inline bool operator!=(const inon_type<T> &b) const { return inon != b.inon; }
  inline bool operator>(const inon_type<T> &b) const { return inon > b.inon; }
  inline bool operator>=(const inon_type<T> &b) const { return inon >= b.inon; }
  inline bool operator<(const inon_type<T> &b) const { return inon < b.inon; }
  inline bool operator<=(const inon_type<T> &b) const { return inon <= b.inon; }

  inline inon_type<T> &operator=(const inon_type<T> &other) {
    inon = other.inon;
    return *this;
  }
};
template <typename T>
inline std::ostream &operator<<(std::ostream &os, inon_type<T> const &inon) {
  return os << inon.inon;
}

namespace std {

template <typename T>
struct hash<inon_type<T>> {
  size_t operator()(const inon_type<T> &inon) const { return inon.inon; }
};

}  // namespace std

template <typename V>
using inon_map = unordered_map<inon_type<V>, unique_ptr<V>>;

class inon_ref_exception : public std::exception {
 public:
  enum reason { UNINITIALIZED_VALUE } r;
  explicit inon_ref_exception(reason r);

  virtual const char *what() const throw();
};

#endif  // INCLUDE_INNOVATION_NUMBER_HXX_
